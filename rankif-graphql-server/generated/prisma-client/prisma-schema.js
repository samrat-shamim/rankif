module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregatePost {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Post {
  id: ID!
  UserId: ID!
  Text: String!
  Attachments: [String!]!
  LikeCount: Int
  CommentCount: Int
  ShareCount: Int
  Score: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateAttachmentsInput {
  set: [String!]
}

input PostCreateInput {
  id: ID
  UserId: ID!
  Text: String!
  Attachments: PostCreateAttachmentsInput
  LikeCount: Int
  CommentCount: Int
  ShareCount: Int
  Score: Float
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  UserId_ASC
  UserId_DESC
  Text_ASC
  Text_DESC
  LikeCount_ASC
  LikeCount_DESC
  CommentCount_ASC
  CommentCount_DESC
  ShareCount_ASC
  ShareCount_DESC
  Score_ASC
  Score_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PostPreviousValues {
  id: ID!
  UserId: ID!
  Text: String!
  Attachments: [String!]!
  LikeCount: Int
  CommentCount: Int
  ShareCount: Int
  Score: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateAttachmentsInput {
  set: [String!]
}

input PostUpdateInput {
  UserId: ID
  Text: String
  Attachments: PostUpdateAttachmentsInput
  LikeCount: Int
  CommentCount: Int
  ShareCount: Int
  Score: Float
}

input PostUpdateManyMutationInput {
  UserId: ID
  Text: String
  Attachments: PostUpdateAttachmentsInput
  LikeCount: Int
  CommentCount: Int
  ShareCount: Int
  Score: Float
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  UserId: ID
  UserId_not: ID
  UserId_in: [ID!]
  UserId_not_in: [ID!]
  UserId_lt: ID
  UserId_lte: ID
  UserId_gt: ID
  UserId_gte: ID
  UserId_contains: ID
  UserId_not_contains: ID
  UserId_starts_with: ID
  UserId_not_starts_with: ID
  UserId_ends_with: ID
  UserId_not_ends_with: ID
  Text: String
  Text_not: String
  Text_in: [String!]
  Text_not_in: [String!]
  Text_lt: String
  Text_lte: String
  Text_gt: String
  Text_gte: String
  Text_contains: String
  Text_not_contains: String
  Text_starts_with: String
  Text_not_starts_with: String
  Text_ends_with: String
  Text_not_ends_with: String
  LikeCount: Int
  LikeCount_not: Int
  LikeCount_in: [Int!]
  LikeCount_not_in: [Int!]
  LikeCount_lt: Int
  LikeCount_lte: Int
  LikeCount_gt: Int
  LikeCount_gte: Int
  CommentCount: Int
  CommentCount_not: Int
  CommentCount_in: [Int!]
  CommentCount_not_in: [Int!]
  CommentCount_lt: Int
  CommentCount_lte: Int
  CommentCount_gt: Int
  CommentCount_gte: Int
  ShareCount: Int
  ShareCount_not: Int
  ShareCount_in: [Int!]
  ShareCount_not_in: [Int!]
  ShareCount_lt: Int
  ShareCount_lte: Int
  ShareCount_gt: Int
  ShareCount_gte: Int
  Score: Float
  Score_not: Float
  Score_in: [Float!]
  Score_not_in: [Float!]
  Score_lt: Float
  Score_lte: Float
  Score_gt: Float
  Score_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  Name: String!
  Email: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  Name: String!
  Email: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  Name_ASC
  Name_DESC
  Email_ASC
  Email_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  Name: String!
  Email: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  Name: String
  Email: String
}

input UserUpdateManyMutationInput {
  Name: String
  Email: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  Name: String
  Name_not: String
  Name_in: [String!]
  Name_not_in: [String!]
  Name_lt: String
  Name_lte: String
  Name_gt: String
  Name_gte: String
  Name_contains: String
  Name_not_contains: String
  Name_starts_with: String
  Name_not_starts_with: String
  Name_ends_with: String
  Name_not_ends_with: String
  Email: String
  Email_not: String
  Email_in: [String!]
  Email_not_in: [String!]
  Email_lt: String
  Email_lte: String
  Email_gt: String
  Email_gte: String
  Email_contains: String
  Email_not_contains: String
  Email_starts_with: String
  Email_not_starts_with: String
  Email_ends_with: String
  Email_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  Email: String
}
`
      }
    